# 实验 2:事务处理与故障恢复

## 实验概述

本次实验为事务处理与故障恢复的实验，意图通过实现数据库日志机制和经典故障恢复算法来更好地理解数据库系统维持事务 ACID 特性的底层实现。

事务处理事数据库系统最核心的功能之一。数据库系统必须保证事务处理的任意过程中意外的系统宕机不会影响事务的 ACID 特性，但出于性能因素考量的 steal+no-force 的脏页刷盘机制让故障情况下磁盘页面的数据违背原子性和持久性。此时，事务处理过程中的日志机制和故障后的恢复算法就起到了至关重要的作用。过顺序追加的日志记录和故障恢复算法对于页面状态的恢复在保证了系统高效性的同时维持了事务的正常运行。

日志格式的设计和故障恢复算法实现是本次实验的难点。日志设计上需要考虑自身保存的数据需要能够支持重做（Redo）或撤销（Undo）操作，并且需要兼顾存储空间和恢复速度（物理和逻辑日志的差异）。故障恢复算法则需要避免记录无用的日志记录以此来维持尽可能低的故障恢复时间。同时，日志和故障恢复的机制要求能覆盖系统在任意时刻宕机的异常情景。本次实验要求完成物理日志的设计和经典的 ARIES 故障恢复算法。

![](../pics/lab2-overview.svg)

## 实验目标

本次实验要求完成如下基础功能：

1. 物理日志的设计：设计物理日志的存储格式，并实现单个日志的重做和撤销函数。

2. ARIES 故障恢复算法：补全分析、重做、撤销三个阶段的函数实现，实现 ARIES 故障恢复算法。

在基础功能之上，实验框架支持完成以下高级功能：

1. 故障恢复过程中的异常处理：实验框架中仅考虑系统仅考虑系统在查询执行中的异常处理，在此基础上添加恢复过程中的异常处理机制，核心为补偿日志机制的实现。

2. 非阻塞检查点机制：实验框架中 Checkpoint 采用阻塞的信息写出方式，在此基础上单开线程实现非阻塞的 Checkpoint 机制，核心为修改 BeginCheckpointLog 和 EndCheckpointLog 的实现。

## 关联知识点

本次实验关联事务管理以及故障恢复章节，重点涉及如下的知识点：

1. 事务的概念：完成本次实验需要理解事务的原子性和持久性的概念。
2. 日志实现方式：物理日志的设计将涉及物理日志的存储格式和物理日志在故障恢复中的性质与作用。
3. ARIES 恢复算法：ARIES 算法的实现将涉及 ARIES 的应用场景和算法流程。

## 相关代码模块

本次实验涉及到代码中如下的功能模块：

-   [log](https://git.tsinghua.edu.cn/dbtrain/dbtrain-lab/-/tree/master/src/log)：日志相关类

    -   [log_record](https://git.tsinghua.edu.cn/dbtrain/dbtrain-lab/-/tree/master/src/log/log_record.h)：各类日志的抽象类，用于衍生出各种具体日志，已经完成。
    -   [log_manager](https://git.tsinghua.edu.cn/dbtrain/dbtrain-lab/-/tree/master/src/log/log_manager.h)：日志管理器，负责日志的记录以及故障恢复的具体执行过程，需要补充恢复算法。
    -   [log_records](https://git.tsinghua.edu.cn/dbtrain/dbtrain-lab/-/tree/master/src/log/log_records)：各类具体的物理日志类，需要补充其中记录增删改日志的重做和撤销。

-   [table](https://git.tsinghua.edu.cn/dbtrain/dbtrain-lab/-/tree/master/src/table)：数据表相关类
    -   [table](https://git.tsinghua.edu.cn/dbtrain/dbtrain-lab/-/tree/master/src/table/table.h)：在实验 1 的基础上添加记录变更时的日志记录功能。

相关功能模块的抽象示意图如下：

![](../pics/lab2-details.svg)

## 基础功能

### 事务的回滚

#### 实验描述

#### 实现思路

### 物理日志的设计

#### 实验描述

补全 log/logs 文件夹下 insert_log.h 和 delete_log.h 来完成物理日志的设计，并修改 Table 类中对应函数。

#### 实现思路

日志设计的核心在于规划日志的存储格式，以及利用存储信息实现 Redo 和 Undo 的方式。可以按照如下的顺序完成本次实验：

-   步骤 0：结合课程内容，思考为什么仅使用物理日志不会影响系统正确性

-   步骤 1：补全 log/insert_log.h 和 log/delete_log.h，实现插入和删除记录的物理日志

框架已经给出了这两类日志所需的必要信息，并实现了序列化和反序列化函数。实验中要求根据存储的信息确定在重做或撤销过程中，如何利用存储信息还原操作对于页面的影响。

-   步骤 2：修改 table/table.cpp，添加记录变更时日志记录的操作

log_manager 文件中的日志管理器 LogManager 类已经提供了追加写出日志的接口，并在内部完成相关的缓存管理功能。
因此本次实验仅需要在实验 1 的基础上，利用 LogManager 提供的追加日志接口(AppendXXXLog)在记录变更时记录对应的日志即可。

完成上面两个步骤即可补全物理日志的功能。

### ARIES 恢复算法

#### 实验描述

补全 log_manager.cpp 中 LogManager 类的 Analyze，Redo，Undo 函数，从而补全 ARIES 故障恢复算法。

#### 实现思路

ARIES 故障恢复算法是针对于 steal+no-force 数据库系统的一种故障恢复算法，在实现前需要充分理解课程中讲解的 ARIES 算法执行流程。
可以按照算法的执行顺序依次补全 3 个函数：

-   步骤 1：补全 LogManager::Analyze，ARIES 算法的分析过程

ARIES 算法的分析过程读取检查点信息，恢复故障时的数据库状态并恢复活跃事务表和脏页表。
实验框架中已经给出了数据库状态的恢复过程，本次实验中需要基于 checkpoint_lsn 恢复活跃事务表、脏页表以及算法所需的 LSN 信息。

-   步骤 2：补全 LogManager::Redo，ARIES 算法的重做过程

ARIES 的重做过程要求按照算法流程（需要步骤 1 中恢复的 LSN 信息）遍历执行日志的重做过程来恢复系统故障时缓存内的脏页状态。
该步骤的正确性依赖于物理日志设计中 Redo 函数的正确性。

-   步骤 3：补全 LogManager::Undo，ARIES 算法的撤销过程

ARIES 的撤销过程需要根据活跃事务表撤销未提交事务产生的页面更新，该步骤的正确性依赖于前两个步骤的正确性和物理日志设计中 Undo 函数的正确性。

完成上面三个步骤即可补全 ARIES 恢复算法。

## 基础功能实现顺序及测例分析

### 实现事务回滚

insert delete

### 实现故障恢复重做

insert delete new_page

### 实现 Aries

## 高级功能

### 故障恢复中的异常处理

#### 实验描述

基础功能仅考虑到查询执行过程中的异常处理过程，高级功能要求在此基础上考虑到故障恢复过程中出现异常时的处理流程，需要引入补偿日志的机制来保证 Undo 过程异常恢复的正确性和执行效率。

#### 实现思路

-   步骤 1：修改数据库故障恢复逻辑，在数据库故障恢复过程中随机发生故障。

-   步骤 2：理解课程中撤销阶段异常恢复的特殊性，理解补偿日志的机制。并在故障恢复算法中添加补偿日志的记录和处理能力。

### 非阻塞检查点机制

#### 实验描述

基础功能中检查点日志按照阻塞的方式追加到磁盘，当 ATT 和 DPT 表容量较大时将影响到系统的查询处理运行，在高级功能中要求采用多线程的方式添加对于非阻塞检查点功能的支持。

#### 实现思路

-   步骤 0：理解实验框架中阻塞检查点的信息记录方法，思考非阻塞检查点的信息记录方式。

-   步骤 1：修改 LogManager::Checkpoint 函数，修改 BeginCheckpointLog 和 EndCheckpointLog 的实现，确定 ATT 和 DPT 实际存储位置。

-   步骤 2：修改 LogManager 类，添加多线程检查点任务结束的异步通知机制，添加多线程情况下的检查点完成的处理函数。

<!--TODO:添加部分教材中的示意图-->

{%
	include-markdown "modules/report.md"
%}

{%
	include-markdown "modules/feedback.md"
%}
