# 实验 3:多版本并发控制

## 实验概述
本次实验为数据库系统并发控制的实验，意图通过实现多版本并发控制机制来让学生们更好地理解数据库系统如何以非阻塞方式处理并发查询处理中读写和写读冲突。

并发查询处理是数据库系统维持高效率、高性能运行的必要条件。但是在并发查询处理中不可避免地会遇到不同事务同时访问相同数据区域的情景，可能发生读写、写读或者写写冲突。
虽然严格按照读写锁的机制执行查询可以保证查询处理的绝对正确性，但是阻塞的处理方式将让查询性能将受到严重限制。在此基础上，为了避免读写和写读冲突造成的系统阻塞问题，多版本并发控制技术得以发展。通过维持多个版本的记录信息，结合版本可见性的控制，数据库系统可以在无阻塞条件处理读写和写读冲突。

并发控制信息的维护和记录可见性分析是本次实验的难点。多版本并发控制依赖于记录所额外存储的版本信息，这要求在记录发生变更时需要同时更新记录的版本信息；同时需要实现记录级别或者页面级别的锁机制来应对写写冲突。在多版本并发控制的架构中，单个记录可以同时维持多个不同的版本来应对不同的事务上下文环境，读取的效率一方面要求系统能够根据版本信息和事务上下文快速确定不同记录版本对于特定事务的可见性，另一方面随着记录版本数量的增加，高效的记录查找机制和过期数据的清理机制才能保证查询性能不会受到严重的负面影响。本次实验要求补全解决读写和写读冲突的多版本并发控制，写写冲突和垃圾回收机制作为可选的高级功能。

![](./pics/lab3-overview.svg) 

## 实验目标
本次实验要求学生完成如下基础功能：

1. ：

2. ：

在基础功能之上，实验框架支持学生完成以下高级功能：

1. 写写冲突的处理：实验框架没有支持并发查询中写写冲突的处理。可以选择如下两种方式解决该问题：
  1. 在框架基础上添加两阶段锁来应对写写冲突。特别地，系统需要采用死锁检测或死锁避免的方式来处理冲突导致的死锁问题。
  2. 在框架基础上添加严格时间戳排序协议应对写写冲突。特别地，需要通过一定检测机制避免无限重复回滚发生（“饿死”问题）。

2. 动态垃圾回收机制：实验框架缺少对于过期的记录数据的清理机制，在框架基础上加入过期数据检测的方法以及动态地垃圾回收进制。该步骤建议开启独立线程于后台完成，同时需要考虑到对于前台查询处理进程的影响。

## 关联知识点

本次实验关联课件并发控制章节，重点涉及如下的知识点：

1. 多版本机制：本次实验需要充分理解多版本并发控制的原理与实现思路。
2. 悲观并发控制：写写冲突的悲观处理将涉及到悲观并发控制的两阶段锁与死锁内容。
3. 乐观并发控制：写写冲突的乐观处理将涉及到时间戳协议与严格时间戳协议。

## 相关代码模块
本次实验涉及到代码中如下的功能模块：

- [log](./modules/index.md)：日志相关结构体
    - [log_record]()：各类日志的抽象结构体，用于衍生出各种具体日志，已经完成。
    - [log_manager]()：日志管理器，负责日志的记录以及故障恢复的具体执行过程，需要补充恢复算法。
    - [logs/*_log]()：各类具体的物理日志结构体，需要补充其中记录增删改日志的重做和撤销。

- [table](./modules/index.md)：数据表相关结构体
    - [table]()：在实验1的基础上添加记录变更时的日志记录功能。

相关功能模块的抽象示意图如下：

![](./pics/lab3-details.svg)


## 基础功能

基础功能侧重于函数功能的补全，通过阅读相关函数的输入输出描述以及函数解释即可完成。

### 物理日志的设计

#### 实验描述

补全log/logs文件夹下insert_log.h和delete_log.h来完成物理日志的设计，并修改Table结构体中对应函数。

#### 实现思路

日志设计的核心在于规划日志的存储格式，以及利用存储信息实现Redo和Undo的方式。可以按照如下的顺序完成本次实验：

- 步骤0：结合课程内容，思考为什么仅使用物理日志不会影响系统正确性

- 步骤1：补全log/insert_log.h和log/delete_log.h，实现插入和删除记录的物理日志

框架已经给出了这两类日志所需的必要信息，并实现了序列化和反序列化函数。实验种要求根据存储的信息确定在重做或撤销过程中，如何利用存储信息还原操作对于页面的影响。

- 步骤2：修改table/table.cpp，添加记录变更时日志记录的操作

log_manager文件中的日志管理器LogManager结构体已经提供了追加写出日志的接口，并在内部完成相关的缓存管理功能。
因此本次实验仅需要在实验1的基础上，利用LogManager提供的追加日志接口(AppendXXXLog)在记录变更时记录对应的日志即可。

完成上面两个步骤即可补全页面组织的功能，并通过如下测例：
(测例)
。


### ARIES恢复算法

#### 实验描述

补全log_manager.cpp中LogManager结构体的Analyze，Redo，Undo函数，从而补全ARIES故障恢复算法。

#### 实现思路

ARIES故障恢复算法是针对于steal+no-force数据库系统的一种故障恢复算法，在实现前需要充分理解课程中讲解的ARIES算法执行流程。
可以按照算法的执行顺序依次补全3个函数：

- 步骤1：补全LogManager::Analyze，ARIES算法的分析过程

ARIES算法的分析过程读取检查点信息，恢复故障时的数据库状态并恢复活跃事务表和脏页表。
实验框架中已经给出了数据库状态的恢复过程，本次实验中需要基于checkpoint_lsn恢复活跃事务表、脏页表以及算法所需的LSN信息。

- 步骤2：补全LogManager::Redo，ARIES算法的重做过程

ARIES的重做过程要求按照算法流程（需要步骤1中恢复的LSN信息）遍历执行日志的重做过程来恢复系统故障时缓存内的脏页状态。
该步骤的正确性依赖于物理日志设计中Redo函数的正确性。

- 步骤3：补全LogManager::Undo，ARIES算法的撤销过程

ARIES的撤销过程需要根据活跃事务表撤销未提交事务产生的页面更新，该步骤的正确性依赖于前两个步骤的正确性和物理日志设计中Undo函数的正确性。

完成上面三个步骤即可补全ARIES恢复算法，并通过如下测例：
。

## 高级功能

高级功能侧重于系统模块的关联分析，需要进一步挖掘函数的调用关系和各个模块之间的关联。分析不同结构体之间的功能差异和数据传递方式才能比较全面地实现高级功能。

### 故障恢复中的异常处理

#### 实验描述

基础功能仅考虑到查询执行过程中的异常处理过程，高级功能要求在此基础上考虑到故障恢复过程中出现异常时的处理流程，需要引入补偿日志的机制来保证Undo过程异常恢复的正确性和执行效率。

#### 实现思路

- 步骤1：理解sqllogicaltest的设计思路，添加在恢复过程中异常的指令和相关测例。

- 步骤2：理解课程中撤销阶段异常恢复的特殊性，理解补偿日志的机制。并在故障恢复算法中添加补偿日志的记录和处理能力。

### 非阻塞检查点机制

#### 实验描述

基础功能中检查点日志按照阻塞的方式追加到磁盘，当ATT和DPT表容量较大时将影响到系统的查询处理运行，在高级功能中要求采用多线程的方式添加对于非阻塞检查点功能的支持。

#### 实现思路

- 步骤0：理解实验框架中阻塞检查点的信息记录方法，思考非阻塞检查点的信息记录方式。

- 步骤1：修改LogManager::Checkpoint函数，修改BeginCheckpointLog和EndCheckpointLog的实现，确定ATT和DPT实际存储位置。

- 步骤2：修改LogManager结构体，添加多线程检查点任务结束的异步通知机制，添加多线程情况下的检查点完成的处理函数。

<!--TODO:添加部分教材中的示意图-->

## 测试说明
本次实验需要通过如下X类测试：

## 实验报告
请各位助教fork本仓库后按照自身的评分需求自行设计实验报告格式。

## 问题反馈

### 框架BUG反馈
有关于实验框架的问题可以提交git issues到如下仓库

或直接发布含有修复补丁和修复说明的pull requests

### 实验讨论区
请各位助教fork本仓库后开设讨论区并在此添加链接。


## 参考文献




# 实验 3：多版本并发控制

## 实验概览

本次实验涉及并发控制模块：

![](./pics/lab3-overview.svg)

![](./pics/lab3-details.svg)

## 实验任务（基础）

### 1. 向记录添加版本信息

### 2. 实现快照隔离

## 实验任务（进阶）

### 1. MVCC 的垃圾回收

### 2. 写写冲突处理
