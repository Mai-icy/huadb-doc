# 实验 3:多版本并发控制

## 实验概述
本次实验为数据库系统并发控制的实验，意图通过实现多版本并发控制机制来让学生们更好地理解数据库系统如何以非阻塞方式处理并发查询处理中读写和写读冲突。

并发查询处理是数据库系统维持高效率、高性能运行的必要条件。但是在并发查询处理中不可避免地会遇到不同事务同时访问相同数据区域的情景，可能发生读写、写读或者写写冲突。
虽然严格按照读写锁的机制执行查询可以保证查询处理的绝对正确性，但是阻塞的处理方式将让查询性能将受到严重限制。在此基础上，为了避免读写和写读冲突造成的系统阻塞问题，多版本并发控制技术得以发展。通过维持多个版本的记录信息，结合版本可见性的控制，数据库系统可以在无阻塞条件处理读写和写读冲突。

并发控制信息的维护和记录可见性分析是本次实验的难点。多版本并发控制依赖于记录所额外存储的版本信息，这要求在记录发生变更时需要同时更新记录的版本信息；同时需要实现记录级别或者页面级别的锁机制来应对写写冲突。在多版本并发控制的架构中，单个记录可以同时维持多个不同的版本来应对不同的事务上下文环境，读取的效率一方面要求系统能够根据版本信息和事务上下文快速确定不同记录版本对于特定事务的可见性，另一方面随着记录版本数量的增加，高效的记录查找机制和过期数据的清理机制才能保证查询性能不会受到严重的负面影响。本次实验要求补全解决读写和写读冲突的多版本并发控制，写写冲突和垃圾回收机制作为可选的高级功能。

![](./pics/lab3-overview.svg) 

## 实验目标
本次实验要求学生完成如下基础功能：

1. ：

2. ：

在基础功能之上，实验框架支持学生完成以下高级功能：

1. 写写冲突的处理：实验框架没有支持并发查询中写写冲突的处理。可以选择如下两种方式解决该问题：
  1. 在框架基础上添加两阶段锁来应对写写冲突。特别地，系统需要采用死锁检测或死锁避免的方式来处理冲突导致的死锁问题。
  2. 在框架基础上添加严格时间戳排序协议应对写写冲突。特别地，需要通过相关检测机制避免无限重复回滚发生（“饿死”问题）。

2. 动态垃圾回收机制：实验框架缺少对于过期的记录数据的清理机制，在框架基础上加入过期数据检测的方法以及动态地垃圾回收进制。该步骤建议开启独立线程于后台完成，同时需要考虑到对于前台查询处理进程的影响。

## 关联知识点

本次实验关联课件并发控制章节，重点涉及如下的知识点：

1. 多版本机制：本次实验需要充分理解多版本并发控制的原理与实现思路。
2. 悲观并发控制：写写冲突的悲观处理将涉及到悲观并发控制的两阶段锁与死锁内容。
3. 乐观并发控制：写写冲突的乐观处理将涉及到时间戳协议与严格时间戳协议。

## 相关代码模块
本次实验涉及到代码中如下的功能模块：

- [log](./modules/index.md)：日志相关结构体
    - [log_record]()：各类日志的抽象结构体，用于衍生出各种具体日志，已经完成。
    - [log_manager]()：日志管理器，负责日志的记录以及故障恢复的具体执行过程，需要补充恢复算法。
    - [logs/*_log]()：各类具体的物理日志结构体，需要补充其中记录增删改日志的重做和撤销。


相关功能模块的抽象示意图如下：

![](./pics/lab3-details.svg)


## 基础功能

基础功能侧重于函数功能的补全，通过阅读相关函数的输入输出描述以及函数解释即可完成。

### 

#### 实验描述



#### 实现思路

- 步骤0：结合课程内容，思考为什么仅使用物理日志不会影响系统正确性

- 步骤1：补全log/insert_log.h和log/delete_log.h，实现插入和删除记录的物理日志

- 步骤2：修改table/table.cpp，添加记录变更时日志记录的操作


完成上面两个步骤即可补全页面组织的功能，并通过如下测例：
(测例)
。


## 高级功能

高级功能侧重于系统模块的关联分析，需要进一步挖掘函数的调用关系和各个模块之间的关联。分析不同结构体之间的功能差异和数据传递方式才能比较全面地实现高级功能。

### 悲观并发控制

#### 实验描述

悲观并发控制要求在框架中加入两阶段锁机制来解决写写冲突问题，需要添加死锁检测或死锁避免机制解决死锁问题。

#### 实现思路

- 步骤1：理解两阶段锁的实现思路，在SystemManager中添加用于锁管理的结构体，并实现锁申请和锁释放接口。

- 步骤2：锁管理器结构体中选择实现死锁避免或死锁检测策略，死锁避免要求分析当前事务的页面更新关系图，死锁检测要求死锁发生时能够正确撤销事务。

### 乐观并发控制

#### 实验描述

乐观并发控制要求在框架中加入严格时间戳协议机制来解决写写冲突问题，需要资源占用的检测机制来避免饿死问题。

#### 实现思路

- 步骤1：理解严格时间戳协议的实现思路，在事务提交前检测严格时间戳规则是否被满足，未满足条件时撤销事务。

- 步骤2：在SystemManager中添加资源占用管理器结构体，用于避免因写写冲突而撤销事务的情况重复发生导致“饿死”问题。

### 动态垃圾回收

#### 实验描述

基础功能中没有考虑过期数据的回收机制，在此基础上单独开设垃圾回收线程异步处理过期数据占用的冗余空间。

#### 实现思路

- 步骤1：在Table结构体中添加垃圾检测机制，结合LogManager给出的活跃事务表判断记录是否已经过期。

- 步骤2：单独创建垃圾回收进程，异步检测各个表中垃圾记录的状态。并在垃圾状态满足合适条件时执行垃圾回收。

- 步骤3：在Table结构体中添加多线程保护的锁，用于保护垃圾回收状态下的页面。

<!--TODO:添加部分教材中的示意图-->

## 测试说明
本次实验需要通过如下X类测试：

## 实验报告
请各位助教fork本仓库后按照自身的评分需求自行设计实验报告格式。

## 问题反馈

### 框架BUG反馈
有关于实验框架的问题可以提交git issues到如下仓库

或直接发布含有修复补丁和修复说明的pull requests

### 实验讨论区
请各位助教fork本仓库后开设讨论区并在此添加链接。


## 参考文献


