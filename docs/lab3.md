# 实验 3:多版本并发控制

## 实验概述
本次实验为数据库系统并发控制的实验，意图通过实现多版本并发控制机制来让学生们更好地理解数据库系统如何以非阻塞方式处理并发查询处理中读写和写读冲突。

并发查询处理是数据库系统维持高效率、高性能运行的必要条件。但是在并发查询处理中不可避免地会遇到不同事务同时访问相同数据区域的情景，可能发生读写、写读或者写写冲突。
虽然严格按照读写锁的机制执行查询可以保证查询处理的绝对正确性，但是阻塞的处理方式将让查询性能将受到严重限制。在此基础上，为了避免读写和写读冲突造成的系统阻塞问题，多版本并发控制技术得以发展。通过维持多个版本的记录信息，结合版本可见性的控制，数据库系统可以在无阻塞条件处理读写和写读冲突。

并发控制信息的维护和记录可见性分析是本次实验的难点。多版本并发控制依赖于记录所额外存储的版本信息，这要求在记录发生变更时需要同时更新记录的版本信息；同时需要实现记录级别或者页面级别的锁机制来应对写写冲突。在多版本并发控制的架构中，单个记录可以同时维持多个不同的版本来应对不同的事务上下文环境，读取的效率一方面要求系统能够根据版本信息和事务上下文快速确定不同记录版本对于特定事务的可见性，另一方面随着记录版本数量的增加，高效的记录查找机制和过期数据的清理机制才能保证查询性能不会受到严重的负面影响。本次实验要求补全解决读写和写读冲突的多版本并发控制，以及两阶段锁协议解决基本写写冲突，而涉及死锁问题的复杂写写冲突以及垃圾回收机制作为可选的高级功能。

![](./pics/lab3-overview.svg) 

## 实验目标
本次实验要求学生完成如下基础功能：

1. 多版本并发控制：修改数据表的增删改查操作，添加版本信息的记录以及记录对于事务的可见性判断。

2. 两阶段锁协议：补全锁管理器，实现两阶段锁协议，解决并发查询处理中的写写冲突问题。

在基础功能之上，实验框架支持学生完成以下高级功能：

1. 写写冲突的死锁处理：实验框架和测例没有涉及并发查询中写写冲突可能导致的死锁问题，需要添加死锁检测或死锁避免机制来解决死锁问题。

2. 动态垃圾回收机制：实验框架缺少对于过期的记录数据的清理机制，在框架基础上加入过期数据检测的方法以及动态地垃圾回收进制。该步骤建议开启独立线程于后台完成，同时需要考虑到对于前台查询处理进程的影响。

## 关联知识点

本次实验关联课件并发控制章节，重点涉及如下的知识点：

1. 多版本并发控制：本次实验需要充分理解多版本并发控制的原理与实现思路。
2. 悲观并发控制：写写冲突的悲观处理将涉及到悲观并发控制的两阶段锁与死锁内容。

## 相关代码模块
本次实验涉及到代码中如下的功能模块：

- [transaction](./modules/index.md)：事务相关结构体
    - [lock_manager]()：


相关功能模块的抽象示意图如下：

![](./pics/lab3-details.svg)


## 基础功能

基础功能侧重于函数功能的补全，通过阅读相关函数的输入输出描述以及函数解释即可完成。

### 多版本并发控制

#### 实验描述

修改Table结构体中增删改查相关函数，添加记录更新时版本信息的记录以及查询记录时记录版本对事务可见性的判断。

#### 实现思路

- 步骤1：修改Table结构体插入、删除以及更新记录的函数，添加版本信息。

在实验1和2中完成的Table和TablePage的处理中没有考虑到事务的版本信息，需要在本次实验中将其补充。

- 步骤2：补全TableScan的IsVisible函数，用于在查询记录时判断记录版本对于事务的可见性。

根据

- 步骤2：修改table/table.cpp，添加记录变更时日志记录的操作


完成上面两个步骤即可补全页面组织的功能，并通过如下测例：
(测例)
。


## 高级功能

高级功能侧重于系统模块的关联分析，需要进一步挖掘函数的调用关系和各个模块之间的关联。分析不同结构体之间的功能差异和数据传递方式才能比较全面地实现高级功能。

### 悲观并发控制

#### 实验描述

悲观并发控制要求在框架中加入两阶段锁机制来解决写写冲突问题，需要添加死锁检测或死锁避免机制解决死锁问题。

#### 实现思路

- 步骤1：理解两阶段锁的实现思路，在SystemManager中添加用于锁管理的结构体，并实现锁申请和锁释放接口。

- 步骤2：锁管理器结构体中选择实现死锁避免或死锁检测策略，死锁避免要求分析当前事务的页面更新关系图，死锁检测要求死锁发生时能够正确撤销事务。

### 动态垃圾回收

#### 实验描述

基础功能中没有考虑过期数据的回收机制，在此基础上单独开设垃圾回收线程异步处理过期数据占用的冗余空间。

#### 实现思路

- 步骤1：在Table结构体中添加垃圾检测机制，结合LogManager给出的活跃事务表判断记录是否已经过期。

- 步骤2：单独创建垃圾回收进程，异步检测各个表中垃圾记录的状态。并在垃圾状态满足合适条件时执行垃圾回收。

- 步骤3：在Table结构体中添加多线程保护的锁，用于保护垃圾回收状态下的页面。

<!--TODO:添加部分教材中的示意图-->

## 测试说明
本次实验需要通过如下X类测试：

## 实验报告
请各位助教fork本仓库后按照自身的评分需求自行设计实验报告格式。

## 问题反馈

### 框架BUG反馈
有关于实验框架的问题可以提交git issues到如下仓库

或直接发布含有修复补丁和修复说明的pull requests

### 实验讨论区
请各位助教fork本仓库后开设讨论区并在此添加链接。


## 参考文献


