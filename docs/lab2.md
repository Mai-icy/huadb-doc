# 实验 2:事务处理与故障恢复

## 实验概述
本次实验为事务处理与故障恢复的实验，意图通过实现数据库日志机制和经典故障恢复算法来让学生们更好地理解数据库系统模维持事务ACID特性的底层实现。

事务处理事数据库系统最核心的功能之一。数据库系统必须保证事务处理的任意过程中意外的系统宕机不会影响事务的ACID特性，但出于性能因素考量的steal+no-force的脏页刷盘机制让故障情况下磁盘页面的数据违背原子性和持久性。此时，事务处理过程中的日志机制和故障后的恢复算法就起到了至关重要的作用。过顺序追加的日志记录和故障恢复算法对于页面状态的恢复在保证了系统高效性的同时维持了事务的正常运行。

日志格式的设计和故障恢复算法实现是本次实验的难点。日志设计上需要考虑自身保存的数据需要能够支持重做（Redo）或撤销（Undo）操作，并且需要兼顾存储空间和恢复速度（物理和逻辑日志的差异）。故障恢复算法则需要避免机系无用的日志记录以此来维持尽可能低的故障恢复时间。同时，日志和故障恢复的机制要求能覆盖系统在任意时刻宕机的异常情景。出于间接性考虑，本次实验要求完成物理日志的设计和经典的ARIES故障恢复算法。

![](./pics/lab2-overview.svg)

## 实验目标
本次实验要求学生完成如下基础功能：

1. 物理日志的设计：设计物理日志的存储格式，并实现单个日志的重做和撤销函数。

2. ARIES故障恢复算法：补全分析、重做、撤销三个阶段的函数实现，实现ARIES故障恢复算法。

在基础功能之上，实验框架支持学生完成以下高级功能：

1. 故障恢复过程中的异常处理：实验框架中仅考虑系统仅考虑系统在查询执行中的异常处理，在此基础上添加恢复过程中的异常处理机制，核心为Undo过程中的故障恢复的实现。

2. 非阻塞Checkpoint机制：实验框架中Checkpoint采用阻塞的信息写出方式，在此基础上单开线程实现非阻塞的Checkpoint机制，核心为修改Begin&EndCheckpointLog的实现。

## 关联知识点

本次实验关联课件事务管理以及故障恢复章节，重点涉及如下的知识点：

1. 事务的概念：完成本次实验需要理解事物的原子性和持久性的概念
2. 日志实现方式：物理日志的设计将涉及物理日志的存储格式和物理日志在故障恢复中的性质与作用
3. ARIES恢复算法：ARIES算法的实现将涉及ARIES的应用场景和算法流程

## 相关代码模块
本次实验涉及到代码中如下的功能模块：

- [log](./modules/index.md)：日志相关结构体
    - [log_record]()：各类日志的抽象结构体，用于衍生出各种具体日志，已经完成。
    - [log_manager]()：日志管理器，负责日志的记录以及故障恢复的具体执行过程，需要补充恢复算法。
    - [logs/*_log]()：各类具体的物理日志结构体，需要补充其中记录增删改日志的重做和撤销。

- [table](./modules/index.md)：数据表相关结构体
    - [table]()：在实验1的基础上添加记录变更时的日志记录功能。

相关功能模块的抽象示意图如下：

![](./pics/lab2-details.svg)


## 基础功能

基础功能侧重于函数功能的补全，通过阅读相关函数的输入输出描述以及函数解释即可完成。

### 物理日志的设计

#### 实验描述

补全log/文件夹下数据表的相关函数以实现按照堆表格式组织的变长记录页面管理功能。

#### 实现思路

日志设计的核心在于规划日志的存储格式，以及利用存储信息实现Redo和Undo的方式。可以按照如下的顺序完成本次实验：

- 步骤0：结合课程内容，思考为什么仅使用物理日志不会影响系统正确性

- 步骤1：补全log/insert_log.h和log/delete_log.h，实现插入和删除记录的物理日志

框架已经给出了这两类日志所需的必要信息，并实现了序列化和反序列化函数。实验种要求根据存储的信息确定在重做或撤销过程中，如何利用存储信息还原操作对于页面的影响。

- 步骤2：修改table/table.cpp，添加记录变更时日志记录的操作

log_manager文件中的日志管理器LogManager结构体已经提供了追加写出日志的接口，并在内部完成相关的缓存管理功能。
因此本次实验仅需要在实验1的基础上，利用LogManager提供的追加日志接口(AppendXXXLog)在记录变更时记录对应的日志即可。

完成上面两个步骤即可补全页面组织的功能，并通过如下测例：
(测例)
。


### ARIES恢复算法

#### 实验描述

补全log_manager.cpp中LogManager结构体的Analyze，Redo，Undo函数，从而补全ARIES故障恢复算法。

#### 实现思路

ARIES故障恢复算法是针对于steal+no-force数据库系统的一种故障恢复算法，在实现前需要充分理解课程中讲解的ARIES算法执行流程。
可以按照算法的执行顺序依次补全3个函数：

- 步骤1：补全LogManager::Analyze，ARIES算法的分析过程

ARIES算法的分析过程读取检查点信息，恢复故障时的数据库状态并恢复活跃事务表和脏页表。
实验框架中已经给出了数据库状态的恢复过程，本次实验中需要基于checkpoint_lsn恢复活跃事务表、脏页表以及算法所需的LSN信息。

- 步骤2：补全LogManager::Redo，ARIES算法的重做过程

ARIES的重做过程要求按照算法流程（需要步骤1中恢复的LSN信息）遍历执行日志的重做过程来恢复系统故障时缓存内的脏页状态。
该步骤的正确性依赖于物理日志设计中Redo函数的正确性。

- 步骤3：补全LogManager::Undo，ARIES算法的撤销过程

ARIES的撤销过程需要根据活跃事务表撤销未提交事务产生的页面更新，该步骤的正确性依赖于前两个步骤的正确性和物理日志设计中Undo函数的正确性。

完成上面三个步骤即可补全ARIES恢复算法，并通过如下测例：
。

## 高级功能

高级功能侧重于系统模块的关联分析，需要进一步挖掘函数的调用关系和各个模块之间的关联。分析不同结构体之间的功能差异和数据传递方式才能比较全面地实现高级功能。

### 优化堆表的插入效率

#### 实验描述

基础功能中仅要求实现最简单的逐页遍历的方式来选择记录的插入页面，高级功能要求在此基础上添加空闲空间数组加速记录插入页面的选择过程。同时设计新的页面结构，按照页面的方式管理空闲空间数组。

#### 实现思路

- 步骤1：设计内存中的空闲空间数组，建议在Table中单独添加新的结构体用于管理空闲空间数组。

- 步骤2：空闲空间数组的页面化管理，按照TablePage的思路设计新的页面结构。将空闲空间数组组织为页面格式进行存储，并在新建Table类后从文件导入。

### 缓存替换算法横向对比

#### 实验描述

基础功能中仅要求实现LRU缓存替换策略，高级功能要求在此基础上添加如时钟算法、LFU、LRU-1等缓存替换算法，并设计相关测例对比不同替换策略的性能差异。

#### 实现思路

- 步骤1：继承BufferStrategy创建新的缓存替换策略结构体，并基于相关算法表述补全实现

- 步骤2：修改BufferPool使用的缓存替换策略

- 步骤3：设计能够体现出缓存替换策略性能差异的测例，并进行多种缓存替换策略的横向对比，需要包括Access和Evict延时的理论和实验分析

<!--TODO:添加部分教材中的示意图-->

## 测试说明
本次实验需要通过如下X类测试：

## 实验报告
请各位助教fork本仓库后按照自身的评分需求自行设计实验报告格式。

## 问题反馈

### 框架BUG反馈
有关于实验框架的问题可以提交git issues到如下仓库

或直接发布含有修复补丁和修复说明的pull requests

### 实验讨论区
请各位助教fork本仓库后开设讨论区并在此添加链接。


## 参考文献


# 实验 2：事务处理与故障恢复

## 实验概览

本次实验涉及故障恢复、日志管理、事务管理模块：

![](./pics/lab2-overview.svg)

![](./pics/lab2-details.svg)





## 实验任务（基础）

### 1. 日志存储

### 2. ARIES 故障恢复算法

## 实验任务（进阶）

### 1. Undo 过程中的故障恢复

### 2. 非阻塞 Checkpoint
