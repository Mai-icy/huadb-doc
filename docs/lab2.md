# 实验 2:事务处理与故障恢复

## 实验概述
本次实验为事务处理与故障恢复的实验，意图通过实现记录的页面组织和经典缓存替换算法来让学生们更好地理解数据库系统页面管理模块的相关功能。

数据库页面管理承担了数据库系统中内存与磁盘的交互枢纽，一方面通过页面缓存的管理实现高效的磁盘页面访问，同时需要具备将不同类型数据页面解析成特定格式化数据的功能，以便于应对上层不同功能模块的各类API接口调用。

页面替换算法和高效率的页面组织是页面管理的难点。高效的磁盘访问依赖于缓存的高命中率，但不规则的页面访问模式增大了缓存替换算法的设计难度；而页面组织需要充分考虑不同类型的页面（记录、索引等）的同时需要结合数据压缩、数据加密等技术保证安全性和效率。全部实现上述内容显然对于本次实验来讲过于宏大，因此在本次实验的基础功能中，我们仅要求同学们完成常规的变长形式记录数据的页面组织和经典的LRU缓存替换算法。

![](./pics/lab2-overview.svg)

## 实验目标
本次实验要求学生完成如下基础功能：

1. 变长记录页面组织：将长度不等的变长记录按照页面形式进行数据组织，实现对于变长记录页面的增删改查操作。

2. LRU缓存替换算法：基于页面的访问序列管理缓存池，按照LRU缓存替换策略进行换出缓存页面的选择。

在基础功能之上，实验框架支持学生完成以下高级功能：

1. 优化堆表的插入效率：实验框架中数据表按照堆表形式进行组织，可以在此基础上设计多级空闲空间数组优化数据插入效率。

2. 缓存替换算横向对比：实验框架中抽象了缓存替换算法接口，通过继承方式可以实现不同的缓存替换策略并进行算法复杂度和缓存命中率等方面的综合研究。


## 关联知识点

本次实验关联课件数据库存储章节，重点涉及如下的知识点：

1. 页面组织：变长记录的页面组织任务将涉及到变长记录的组织方式
2. 文件组织：堆表的插入效率优化任务将涉及到堆表组织、空闲空间数组的设计以及顺序表的实现
3. 缓冲区：缓存替换算法的实现将涉及到各类缓存替换策略的原理与算法流程

## 相关代码模块
本次实验涉及到代码中如下的功能模块：

- [table](./modules/index.md)：数据表相关操作
    - [record]()：记录结构体，已经完成。
    - [table]()：数据表结构体，需要补充记录插入和删除函数。
    - [table_page]()：变长记录页面结构体，需要补充页面内部记录插入和阐述的函数。
    - [table_scan]()：用于全表扫描，需要补获取下条记录的函数来实现数据遍历。

- [storage](./modules/index.md)：用于管理内存和外存的交互
    - [buffer_strategy]()：缓存替换算法的抽象。
    - [lru_buffer_strategy]()：LRU缓存替换算法的抽象，需要补全实现。

相关功能模块的抽象示意图如下：

![](./pics/lab2-details.svg)


## 基础功能

基础功能侧重于函数功能的补全，通过阅读相关函数的输入输出描述以及函数解释即可完成。

### 变长记录的页面组织

#### 实验描述

补全Table文件夹下数据表的相关函数以实现按照堆表格式组织的变长记录页面管理功能。

#### 实现思路

页面组织的核心是将格式化的不定长记录结构体组织到固定大小的页面文件中，便于后续存储到持久化磁盘。可以按照如下的顺序完成本次实验：

- 步骤1：补全table_page.cpp，实现单个页面内的记录操作

该文件为变长的记录页面管理的相关函数实现，本次实验中需要先补全对于页面内的相关操作：包括页面内记录的插入、删除、更新、获取。
改结构体内的函数用于将格式化的记录结构体组织到无格式的页面中，从而实现内存中结构体到磁盘中无格式数据的转化。

- 步骤2：补全table.cpp，以堆表的格式管理单个记录

该文件为堆表的实现，用于向查询处理过程中的各种查询算子提供一种整体上的便于访问的数据表接口，让上层算子不需要关注底层数据表的实现方式。
实验框架中选择实现上最简单的堆表作为数据表的组织方式。本次实验中需要补全数据表级别的增删改查函数。需要依赖于步骤1中完成的接口。

完成上面两个步骤即可补全页面组织的功能，并通过如下测例：
(测例)
。


### LRU缓存替换算法

#### 实验描述

补全Storage文件夹下的LRU缓存替换策略结构体，实现页面缓存池的LRU缓存替换策略。

#### 实现思路

缓存替换的核心是基于输入的页面访问序列，选择按照算法标准设计的换出页面编号。可以按照如下的顺序完成本次实验：

- 步骤1：补全lru_buffer_strategy.h，设计LRUBufferStrategy结构体

BufferStrategy采用了经典的策略模式。默认的函数模板提供了缓存池调用的接口，用具体的替换策略补全纯虚的抽象接口。
首先需要再LRUBufferStrategy结构体中添加记录信息所需的成员变量。

- 步骤2：补全lru_buffer_strategy.cpp，补全空缺的Access和Evict策略接口。

Access函数：表示发生了页面访问，根据访问页面更新步骤1种添加的成员变量。

Evict函数：按照LRU算法的规则，利用步骤1中添加的成员变量确定最久未使用的页面作为换出页面即可。

完成上面两个步骤即可补全LRU缓存替换算法，并通过如下测例：
。

## 高级功能

高级功能侧重于系统模块的关联分析，需要进一步挖掘函数的调用关系和各个模块之间的关联。分析不同结构体之间的功能差异和数据传递方式才能比较全面地实现高级功能。

### 优化堆表的插入效率

#### 实验描述

基础功能中仅要求实现最简单的逐页遍历的方式来选择记录的插入页面，高级功能要求在此基础上添加空闲空间数组加速记录插入页面的选择过程。同时设计新的页面结构，按照页面的方式管理空闲空间数组。

#### 实现思路

- 步骤1：设计内存中的空闲空间数组，建议在Table中单独添加新的结构体用于管理空闲空间数组。

- 步骤2：空闲空间数组的页面化管理，按照TablePage的思路设计新的页面结构。将空闲空间数组组织为页面格式进行存储，并在新建Table类后从文件导入。

### 缓存替换算法横向对比

#### 实验描述

基础功能中仅要求实现LRU缓存替换策略，高级功能要求在此基础上添加如时钟算法、LFU、LRU-1等缓存替换算法，并设计相关测例对比不同替换策略的性能差异。

#### 实现思路

- 步骤1：继承BufferStrategy创建新的缓存替换策略结构体，并基于相关算法表述补全实现

- 步骤2：修改BufferPool使用的缓存替换策略

- 步骤3：设计能够体现出缓存替换策略性能差异的测例，并进行多种缓存替换策略的横向对比，需要包括Access和Evict延时的理论和实验分析

<!--TODO:添加部分教材中的示意图-->

## 测试说明
本次实验需要通过如下X类测试：

## 实验报告
请各位助教fork本仓库后按照自身的评分需求自行设计实验报告格式。

## 问题反馈

### 框架BUG反馈
有关于实验框架的问题可以提交git issues到如下仓库

或直接发布含有修复补丁和修复说明的pull requests

### 实验讨论区
请各位助教fork本仓库后开设讨论区并在此添加链接。


## 参考文献


# 实验 2：事务处理与故障恢复

## 实验概览

本次实验涉及故障恢复、日志管理、事务管理模块：

![](./pics/lab2-overview.svg)

![](./pics/lab2-details.svg)





## 实验任务（基础）

### 1. 日志存储

### 2. ARIES 故障恢复算法

## 实验任务（进阶）

### 1. Undo 过程中的故障恢复

### 2. 非阻塞 Checkpoint
