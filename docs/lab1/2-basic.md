# 基础功能

## 任务 1：变长记录的页面组织（12 分）

本任务中，你需要补全 `table.cpp`, `table_page.cpp` 以及 `table_scan.cpp`，来实现记录的增删改查功能。

实验框架的文件组织方式为堆表，记录的顺序没有限制。页面之间采用链表连接，页面组织支持变长记录，页面头由以下几个字段组成：

| 变量名         | 变量类型  | 长度 | 作用                   |
| -------------- | --------- | ---- | ---------------------- |
| page_lsn\_     | lsn_t     | 8    | PageLSN，实验 2 中使用 |
| next_page_id\_ | pageid_t  | 4    | 记录下一个页面的页面号 |
| lower\_        | db_size_t | 2    | 页面空闲空间起始位置   |
| upper\_        | db_size_t | 2    | 页面空闲空间终止位置   |

每条记录都由记录头、空值向量和数据组成，记录头包含如下几个字段：

| 变量名    | 变量类型 | 长度 | 作用                                      |
| --------- | -------- | ---- | ----------------------------------------- |
| deleted\_ | bool     | 1    | 标注记录是否删除                          |
| xmin\_    | xid      | 4    | （实验 3）插入该数据的事务 id             |
| xmax\_    | xid      | 4    | （实验 3）删除该数据的事务 id             |
| cid\_     | cid_t    | 4    | （实验 3）插入该数据的事务内部 command id |

在实验 1 中，你只需要关注 deleted\_ 字段即可。

变长记录中的变长字段采用长度+数据的方式记录在原地，注意与教材介绍的方法不同，为简化设计，实验框架中没有将所有变长字段放于记录最后。

本任务中，第一步你需要补全记录插入和读取的代码，正确实现后可以通过测例`10-insert.test`。

我们首先来看插入记录的部分，插入记录的上层调用位于`insert_executor.cpp`，调用了 table\_ 对象的 InsertRecord 函数，该函数返回插入记录的 rid\_（rid\_表示一条记录的位置，由页面 id 和页面中的槽 id 组成）。

Table 类的 InsertRecord 函数是你需要实现的部分。

### 实验描述

补全 table 文件夹下数据表的相关函数以实现按照堆表格式组织的变长记录页面管理功能。

### 实现思路

页面组织的核心是将格式化的不定长记录组织到固定大小的页面文件中，便于后续存储到持久化磁盘。可以按照如下的顺序完成本次实验：

-   步骤 1：补全 table_page.cpp，实现单个页面内的记录操作

该文件为变长的记录页面管理的相关函数实现，本次实验中需要先补全对于页面内的相关操作：包括页面内记录的插入、删除、更新、获取。
该类内的函数用于将格式化的记录组织到无格式的页面中，从而实现内存数据到磁盘中无格式数据的转化。

-   步骤 2：补全 table.cpp，以堆表的格式管理单个记录

该文件为堆表的实现，用于向查询处理过程中的各种查询算子提供一种整体上的便于访问的数据表接口，让上层算子不需要关注底层数据表的实现方式。
实验框架中选择实现上最简单的堆表作为数据表的组织方式。本次实验中需要补全数据表级别的增删改查函数。需要依赖于步骤 1 中完成的接口。

完成上面两个步骤即可补全页面组织的功能。

## 任务 2：LRU 缓存替换算法（3 分）

### 实验描述

补全 storage 文件夹下的 LRU 缓存替换策略类，实现页面缓存池的 LRU 缓存替换策略。

### 实现思路

缓存替换的核心是基于输入的页面访问序列，选择按照算法标准设计的换出页面编号。可以按照如下的顺序完成本次实验：

-   步骤 1：补全 lru_buffer_strategy.h，设计 LRUBufferStrategy 类

BufferStrategy 采用了经典的策略模式。默认的函数模板提供了缓存池调用的接口，用具体的替换策略补全纯虚的抽象接口。
首先需要再 LRUBufferStrategy 类中添加记录信息所需的成员变量。

-   步骤 2：补全 lru_buffer_strategy.cpp，补全空缺的 Access 和 Evict 策略接口。

Access 函数：表示发生了页面访问，根据访问页面更新步骤 1 中添加的成员变量。

Evict 函数：按照 LRU 算法的规则，利用步骤 1 中添加的成员变量确定最久未使用的页面作为换出页面即可。

完成上面两个步骤即可补全 LRU 缓存替换算法。

## 基础功能实现顺序及测例分析

### table_page 的插入和删除

### table 的插入和删除

### Halloween Problem

### 缓存管理
